---
title: 深入理解JVM笔记 自动内存管理
date: 2017-09-18 10:11:03
categories: ["Java进阶","JVM"]
tags:
	- JVM
	- 自动内存管理
---

这段时间将会学习JVM的相关知识，深入理解JVM是一本不错的介绍JVM的书籍，所以这个阶段就重这本书入手，深入研究下JVM的原理和机制，这对于在代码中对于内存的处理会有相当大的好处
<!-- more -->

自动内存管理主要从下面四章来学习

## 一、Java内存区域与内存溢出异常

&emsp;&emsp;我们的程序在被虚拟机执行的时候，Java虚拟机会将它所管理的内存划分不同的区域。不同的区域负责不同的功能。

### 运行时数据区域

<div align="center">
	<img src="http://ovpqrf5pq.bkt.clouddn.com/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="JVM运行时区域" style="width:600px;height: 400px">
</div>

上图展示了JVM运行时的内存区域,红色区域是每个线程私有的内存区域，其他是线程共享的内存区域

#### 程序计数器
程序计数器是记录程序运行到哪里，下一步该执行哪步操作。程序计数器是线程级别的，所以每一个线程都会有一个独立的程序计数器，CPU在切换线程的时候计数器可以记录程序执行位置，在重新切换回来时候可以在原有位置继续执行，各个线程之间的计数器互不影响。如果执行的是Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果是本地方法，则计数器记录的是空。
程序计数器是唯一一个不会出现OutOfMemoryErro异常的区域

#### Java虚拟机栈
Java虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行都会创建一个栈帧用来存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法从调用到完成的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程
局部变量表存放了编译期可知的基本数据类型、对象引用和retrunAddress类型

Java虚拟机栈中规定了两种内存状况:
##### 1. StackOverflowError异常
	线程请求的栈深度大于虚拟机允许的深度抛出StackOverflowError异常
##### 2. OutOfMemoryError异常
	对于可以动态扩展的虚拟机栈在申请不到足够的内存时候抛出OutOfMemoryError异常

#### 本地方法栈
本地方法栈与Java虚拟机栈类似，不同的是Java虚拟机栈执行的是Java方法服务，本地方法栈为虚拟机使用到的Native方法服务

#### Java堆
Java堆是被所有线程共享的内存区域，是Java虚拟机管理的内存中最大的一块。此内存区域存放的是对象实例，对象实力都在该区域分配内存。
Java堆区域是GC垃圾回收器管理的主要区域
Java堆处于物理上连续不断的内存空间中，只要逻辑上是连续的即可。如果堆内没有完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常

#### 方法区
方法区也是各个线程共享的区域，主要存放已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。
方法区垃圾回收的主要目标是针对常量池的回收和对类型的卸载。

> 运行时常量池是方法区的一部分,用于存放编译期生成的各种字面量和符号引用，这部分内容是在类加载后存放到常量池中。
> 运行时常量池另外一个特性-动态性。Java语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中，这种特性用的比较多的是`String`的`intern()`方法

当方法区无法满足内存分配的需求时，将会抛出OutOfMemoryError异常

以上关于`运行时数据区域`说明有个博客例子说明的很清晰，可以参考下:
[http://www.cnblogs.com/dingyingsi/p/3760730.html](http://www.cnblogs.com/dingyingsi/p/3760730.html)
[http://www.cnblogs.com/zhulin-jun/p/5753928.html](http://www.cnblogs.com/zhulin-jun/p/5753928.html)

### 对象创建
虚拟机遇到一个new指令后，首先检查这个指令在常量池中是否可以定位到一个类的符号引用,并且检查这个符号引用代表的类是否加载、解析和初始化。如果没有则需要先执行类加载过程，类加载完成后虚拟机给新生对象分配内存，对于Java堆中规整的内存(已使用和未使用的内存顺序排列，没有相互交错)，则移动内存指针来分配内存，对于非规整的内存需要虚拟机维护的列表来分配。

内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值，接下来虚拟机需要对对象进行必要的设置，包括对象是哪个类的实例、如何才能找到类的元数据信息等。这样一个新对象则创建完成，后续就是代码执行过程。


---------

## 二、垃圾回收器与内存分配策略

## 三、虚拟机性能监控与故障处理工具

## 四、调优案例分析与是实战


参考：
1. [Feng_zhulin](http://www.cnblogs.com/zhulin-jun/p/5753928.html)
2. [深入理解JVM(豆瓣)](https://book.douban.com/subject/6522893/)
3. [JVM 内存初学 (堆(heap)、栈(stack)和方法区(method) )](http://www.open-open.com/lib/view/open1432200119489.html)