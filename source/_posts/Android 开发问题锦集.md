---
title: Android 开发问题锦集
date: 2018-09-19 19:50:38
categories: Android
tags: 
    - Android
    - Bug
---

记录在Android开发过程中出现的Bug，持续更新！

<!-- more -->

## 解决Didn't find class "com.baiyuas.ui.MainActivity" on path: DexPathList[[zip fi

对于这个问题有多个原因，比较常见的是因为在清单文件里配置的和类的包名不一直，我这里出现这个问题原因是我在工程中是有来**multidex**分包，但是在**Application**中没有配置代码，

	@Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(base);
    }

如果不配置，程序打包多个dex,所以部分类无法加载

## 解决****/ data binding error ****msg:Cannot find the setter for attribute 'android:onClick' with parameter type lambda

我用的Android Studio 3.0，之前工程一直好好的，今天编译一下，就莫名的出这个错误，我的xml文件肯定没有问题，很多时候是data binding 在xml中的语法有问题会出现类似daata binding的错误，但是我这个肯定没有问题，之前一直是好好的，最后去官网研究研究，发现来这个
> Data Binding Compiler V2 

于是按着说明配置了下，在一编译好了，这个使用与AndroidStudio3.0 与v1的区别

In compiler v2:

    ViewBinding classes are generated by the Android Gradle Plugin before the java compiler. This avoids getting too many false positive errors if java compilation fails for an unrelated reason.
    In V1, the binding classes for libraries would be regenerated when the app is compiled (to share generated code and access to the final `BR` and `R` files). In V2, libraries keep their generated binding classes as well as the mapper information which improves data binding performance significantly for multi-module projects.

Note that this new compiler is backwards incompatible so libraries compiled with v1 cannot be used by v2 or vice versa.

V2 also drops some rarely used functionality to allow these changes:

    In V1, an app was able to provide binding adapters which can override the adapters in dependencies. In V2, it will only take effect for the code in your own module / application and its dependents.
    Previously, if a layout file in 2 or more different resource configurations contained a View with the same id but different class, Data Binding would find the most common parent class. In V2, it will always default to View when types do not match between configurations.
    In V2, different modules cannot use the same package name in the manifest since Data Binding will use that package name to generate the binding mapper class.

大概就是V2比v1优化了很多东西，配置新版的gradlw和studio效果更好，配置方法在你的**gradle.properties**中增加如下

	 android.databinding.enableV2=true

## 解决testInstrumentationRunner 'android.test.InstrumentationTestRunner'的作用

使用android studio新建的工程在app/build.gradle中

    defaultConfig {
        applicationId "com.example.android.architecture.blueprints.todomvp"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
    }

这里会配置**testInstrumentationRunner 'android.test.InstrumentationTestRunner** 一开始不知道什么意思，后来做个单元测试知道了， 这个配置主要是包装在工程中使用了分包后可以正常测试，如果工程使用了分包，但是没有配置这个，在使用单元测试的时候会报错找不到对应的类

## 解决 Cannot set the value of read-only property 'outputFile' for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=productDebug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl.

在gradlew 3.0之前我们输出apk到指定目录是这样
	applicationVariants.all { variant ->
                variant.outputs.each { output ->
                    //开始输出,自定义输出路径
                    output.outputFile = new File(“xxx/xxx.apk”)
                }
            }

但是3.0以后这样就会报错，需要修改如下：

    //这是应用编译完成
    applicationVariants.all { variant ->
        variant.outputs.all {
            outputFileName = new File("./release/" + getDate() + "_v" + cfg.version_name + ".apk")
        }
    }

## #702 java.lang.IllegalStateException
Fragment already added: ShareDialog{1a18613 #0 bottom_share}
android.support.v4.app.FragmentManagerImpl.addFragment(FragmentManager.java:1891)

解决方案
1. 该异常表示fragment已经被添加过，通常是因为重复添加fragment导致的，建议调用FragmentTransaction.add方法，先判断fragment.isAdded()。
[解决方案]：以下是参考解决方案：

	if (fragment.isAdded()) { 
	    fragmentManager.beginTransaction().show(fragment).commit();
	} else {
	    fragmentManager.beginTransaction().remove(fragment).commit();
	    frament = new Fragment();
	    fragmentManager.beginTransaction().add(R.id.layout_frame, fragment).commit();
	}

2, 该异常还经常发生在使用DialogFragment的场景下，DialogFragment也是Fragment的一个子类，
其show()方法等同于FragmentTransaction.add()方法，dismiss()方法等同于FragmentTransaction.remove()方法。所以发生异常的原因同上。解决方案如下：

    if (dialogFragment.isAdded())
    	dialogFragment.dismiss();
    else
    	dialogFragment.show();

## 解决Activity切换动画无效果问题
 
我这是Activity切换动画是通过主题统一设置的，在sytle中配置了

	<item name="android:windowAnimationStyle">@style/Al.Animation.Activity</item>

但是总是没有效果，最后网上找了一大圈，终于发现，在设置主题时候我这设置了Activity背景透明属性

	android:windowIsTranslucent="true"

去掉这个属性就可以了，设置这个属性，切换动画就无效果

## 使用gradlew 动态传入参数 -P

在使用`gradle`w命令打包时候不想每次都去修改`build.gradle`文件中设置的变量，这时候就需要使用动态参数

* 命令行

如果你使用的命令行打包，需要通过`graldew`的`-P`参数类传入。

    $ ./gradlew clean assembleRelease -PversionName=1.2.3 // linux命令
    C:Project> gradlew clean assembleRelease -PversionName=1.2.3 // Window

> ***注***
这里有个点需要注意,如果你传入的参数在代码中定义为字符串需要转移，例如 `-PuserName=\"Hello\"`

* Android Studio打包

使用工具打包，需要在Android Studio中配置参数 路径 `File->Setting->Compiler->Command-line Options`中配置`-PversionName=1.2.3`

## 使用Jetpack Navigation 时候没有图形化设计也没有Navigation选项

Navigation功能需要手动开启，

    Setting->Experimental->Editor->Enable Navigation

